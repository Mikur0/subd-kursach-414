***

### <p align="center"> Министерство образования, науки и молодежной политики Республики Коми

### <p align="center"> ГПОУ «Сыктывкарский политехнический техникум»

## <p align="center"> Курсовая работа

## <p align="center"> Тема: Разработка базы данных и программного обеспечения для склада автотоваров </p>

#### <p align="right"> Выполнил

 <p align="right">студент 4 курса

<p align="right">414 группы

<p align="right">Ломовицкий Алексей Игоревич 

#### <p align="right">Проверил

<p align="right">Пунгин И.В.

<p align="right">Дата проверки:

<p align="center">Сыктывкар, 2025 г.

***

## Задание на курсовую работу по МДК 11.01 "Технология разработки и защиты баз данных"

Специальность: <ins> 09.02.07 "Информационные системы и программирование"  </ins>

Тема курсовой работы: **Разработка базы данных для автоматизации складского учета автотоваров**

Срок представления работы к защите: <ins> 22 декабря 2025 года. </ins>

**Перечень подлежащих разработке вопросов:**

1. **Анализ предметной области и теоретическое обоснование.**
    1.1. Роль информационных систем в логистике.
    1.2. Сравнительный анализ моделей данных.
    1.3. Постановка задачи (адресное хранение, партионный учет).

2. **Инфологическая (концептуальная) модель.**
    2.1. Выделение сущностей и атрибутов.
    2.2. Построение ER-диаграммы.

3. **Логическая и физическая структура БД.**
    3.1. Нормализация отношений (1NF, 2NF, 3NF).
    3.2. Обоснование выбора СУБД PostgreSQL.
    3.3. Физическая реализация (типы данных, ограничения).

4. **Реализация серверной логики.**
    4.1. Разработка триггеров и хранимых функций.
    4.2. Создание пользовательских представлений (Views).

5. **Разработка клиентского программного обеспечения.**
    5.1. Обоснование выбора языка Python.
    5.2. Реализация графического интерфейса и взаимодействия с БД.

Руководитель работы __________________ <ins> И. В. Пунгин </ins>

Задание принял к исполнению _______________________________ <ins> Ломовицкий А.И. </ins>

***

## <a id="content">Содержание</a>

1. [Введение](#introduction)
2. [Основная часть](#main)
    - [1. Анализ предметной области и теоретические основы](#analysis)
    - [2. Инфологическая (концептуальная) модель базы данных](#infological_model)
    - [3. Логическая структура БД и нормализация](#logical_structure)
    - [4. Физическая структура базы данных и выбор СУБД](#physical_structure)
    - [5. Реализация серверной части проекта](#db_realization)
    - [6. Разработка клиентского программного обеспечения](#software_dev)
3. [Заключение](#conclusion)
4. [Список использованных информационных источников](#literature)
5. [Приложения](#applications)

***

## <a id="introduction">Введение</a>

### Актуальность темы
В условиях современной рыночной экономики и высокой конкуренции ключевым фактором успеха любого торгового предприятия является эффективность управления внутренними бизнес-процессами. Для магазинов автозапчастей, работающих со сложным и обширным ассортиментом, критически важную роль играет организация складского хозяйства. Номенклатура современного автомобиля может включать тысячи наименований деталей, многие из которых имеют визуальное сходство, но отличаются техническими характеристиками.

Традиционные методы учета, основанные на бумажных носителях или простейших табличных редакторах (например, MS Excel), в современных реалиях демонстрируют свою несостоятельность. Они характеризуются низкой скоростью обработки информации, высокой вероятностью возникновения ошибок из-за «человеческого фактора», отсутствием возможности многопользовательского доступа и сложностью формирования аналитической отчетности. Отсутствие оперативной информации о реальных остатках приводит к пересортице (расхождению фактического и учетного количества), замораживанию оборотных средств в неликвидных товарах и, как следствие, к прямым финансовым убыткам.

В связи с этим, автоматизация складского учета посредством внедрения реляционных баз данных (РБД) становится не просто конкурентным преимуществом, а необходимым условием выживания бизнеса. Информационная система позволяет упорядочить хранение данных, обеспечить их целостность, непротиворечивость и мгновенный доступ к ним.

### Цель работы
Целью данной курсовой работы является проектирование и программная реализация информационной системы (базы данных и клиентского приложения) для автоматизации складского учета магазина автотоваров. Система должна решать проблемы адресного хранения, партионного учета и контроля сроков годности продукции.

### Задачи работы
Для достижения поставленной цели необходимо решить ряд исследовательских и практических задач:
1.  Провести системный анализ предметной области «Склад автозапчастей», изучить документооборот и информационные потоки.
2.  Изучить теоретические основы проектирования баз данных, включая теорию нормализации и обеспечения целостности.
3.  Обосновать выбор системы управления базами данных (СУБД) PostgreSQL и языка программирования Python как инструментов реализации.
4.  Разработать инфологическую и логическую модели данных.
5.  Реализовать физическую модель базы данных, включая создание таблиц, индексов и ограничений.
6.  Разработать серверную бизнес-логику с использованием триггеров для автоматизации рутинных операций.
7.  Создать клиентское приложение с графическим интерфейсом для удобного взаимодействия персонала с системой.

***

## <a id="main">Основная часть</a>

### <a id="analysis">1. Анализ предметной области и теоретические основы</a>

***

### 1.1. Роль информационных систем в складской логистике и специфика автобизнеса

Складская логистика представляет собой сложную систему управления материальными потоками, включающую процессы приемки, обработки, хранения, комплектации и отгрузки товаров. В современных экономических условиях склад перестает быть просто местом для хранения запасов; он трансформируется в высокотехнологичный узел распределения, от эффективности которого напрямую зависит рентабельность торгового предприятия.

Для сферы автозапчастей характерна высокая степень сложности складских процессов, обусловленная следующими факторами:
1.  **Широта ассортимента (SKU):** Номенклатура среднего магазина автозапчастей может насчитывать десятки тысяч позиций — от мельчайших метизов и уплотнительных колец до крупногабаритных кузовных деталей и агрегатов.
2.  **Наличие аналогов и кросс-номеров:** Одна и та же деталь может производиться разными брендами (например, Bosch, Denso, NGK) и иметь разные артикулы, будучи при этом технически идентичной. Без информационной системы отследить взаимозаменяемость практически невозможно.
3.  **Высокие требования к точности:** Визуальное сходство многих деталей (например, тормозных колодок или фильтров) при отсутствии строгого учета приводит к ошибкам при подборе и выдаче товара клиенту, что влечет за собой возвраты и репутационные риски.

В условиях «ручного» управления или использования неспециализированного программного обеспечения (например, таблиц MS Excel) возникают системные проблемы:
*   **Зависимость от персонала:** Знание о том, где лежит конкретный товар, часто хранится в памяти отдельных сотрудников («незаменимых кладовщиков»). При их отсутствии работа склада парализуется.
*   **Низкая скорость обработки заказов:** Время, затрачиваемое на поиск товара без системы адресного хранения, может составлять до 60% от общего времени выполнения заказа.
*   **«Замораживание» оборотных средств:** Отсутствие оперативных данных о реальных остатках приводит к тому, что менеджеры заказывают товар, который уже есть на складе, но числится потерянным, или, наоборот, продают отсутствующие позиции.

Внедрение **Автоматизированной Информационной Системы (АИС)** класса WMS (Warehouse Management System) или разработка собственной базы данных решает эти проблемы путем перехода к управлению на основе данных. Информационная система становится «единым источником правды» для всех подразделений компании.

Ключевым элементом такой системы является **технология адресного хранения**. Складское пространство виртуально разбивается на зоны, ряды, стеллажи и полки (ячейки), каждой из которых присваивается уникальный идентификатор (например, `A-01-12`). При приемке товара база данных фиксирует не просто факт наличия детали, а её точное местоположение. Это позволяет:
1.  **Оптимизировать маршрут комплектовщика:** Система может выстроить путь сбора заказа так, чтобы сотрудник прошел минимальное расстояние.
2.  **Проводить инвентаризацию без остановки склада:** Можно пересчитывать остатки по конкретным ячейкам или товарным группам в рабочее время.
3.  **Реализовать стратегии FIFO/FEFO:** Для товаров с ограниченным сроком годности (автохимия, масла, аккумуляторы) система автоматически предлагает отгружать партии с наименьшим остаточным сроком хранения (First Expired — First Out), предотвращая убытки от списания просроченной продукции.

Таким образом, разработка и внедрение реляционной базы данных для склада автотоваров является не просто технической задачей, а необходимым условием для построения прозрачного, управляемого и прибыльного бизнеса.

#### 1.2. Сравнительный анализ моделей данных
При проектировании системы был проведен выбор между различными моделями организации данных:
1.  **Иерархическая модель:** Представляет данные в виде древовидной структуры. Недостатком является сложность изменения структуры и дублирование данных при связях «многие-ко-многим».
2.  **Сетевая модель:** Позволяет произвольные связи, но сложна в реализации и администрировании.
3.  **Реляционная модель:** Основана на математической теории множеств и представляет данные в виде двумерных таблиц, связанных между собой ключами.

Для решения задач курсовой работы была выбрана **реляционная модель**. Она является де-факто стандартом для учетных систем благодаря своей гибкости, понятности и наличию мощного языка запросов SQL (Structured Query Language). Реляционная модель гарантирует, что данные будут храниться структурировано, а связи между ними будут надежно защищены механизмами ссылочной целостности.

#### 1.3. Постановка задачи
Необходимо разработать систему, удовлетворяющую следующим требованиям:
*   **Адресное хранение:** Каждый товар привязан к коду ячейки (Зона-Ряд-Полка).
*   **Единый реестр контрагентов:** Хранение поставщиков и клиентов в одной сущности.
*   **Партионный учет:** Любое изменение остатка должно подтверждаться документом (Приход/Расход/Списание).
*   **Контроль качества:** Система должна отслеживать сроки годности товаров (масла, химия).


***

### <a id="infological_model">2. Инфологическая (концептуальная) модель базы данных</a>

Этап инфологического проектирования является ключевым при разработке базы данных. Его цель — создание семантической (смысловой) модели предметной области, независимой от конкретной СУБД. На этом этапе определяются информационные объекты, их характеристики и правила взаимодействия.

#### 2.1. Выделение информационных объектов (Сущностей)

На основе анализа предметной области «Склад автотоваров» (п. 1.1) были выделены следующие сущности:

1.  **Товар (Product):**
    Это стержневая сущность системы. В контексте автобизнеса товар характеризуется не только названием, но и уникальной комбинацией «Артикул + Бренд». Также важной особенностью является необходимость хранения информации о сроках годности (для масел и химии) и адресе хранения.
2.  **Категория (Category):**
    Справочная сущность, предназначенная для иерархической классификации товаров (например, «Тормозная система», «Двигатель», «Электрика»). Позволяет группировать номенклатуру в отчетах.
3.  **Производитель (Manufacturer):**
    Справочная сущность. Вынесение бренда в отдельную таблицу необходимо для соблюдения правил нормализации, так как написание одного и того же бренда может варьироваться (например, "Kia", "KIA", "Kia Motors").
4.  **Контрагент (Contractor):**
    Сущность, представляющая юридическое или физическое лицо, участвующее в товарообороте. Было принято решение использовать паттерн **«Обобщение»**: вместо создания двух разных таблиц «Поставщики» и «Клиенты» используется одна сущность с атрибутом «Тип». Это оправдано тем, что атрибутивный состав (Название, ИНН, Телефон, Адрес) у них идентичен.
5.  **Складское движение (Stock Movement):**
    Транзакционная сущность, представляющая собой «шапку» документа (накладной). Она фиксирует сам факт совершения хозяйственной операции, её время и участников.
6.  **Позиция движения (Movement Item):**
    Сущность-детализация. Хранит информацию о составе документа: какой именно товар, в каком количестве и по какой цене был перемещен в рамках конкретного «Складского движения».

#### 2.2. Описание атрибутивного состава

Для каждой выделенной сущности был определен набор атрибутов, необходимый и достаточный для решения поставленных задач:

*   **Сущность «Товар»:**
    *   *Идентификатор:* Уникальный ключ.
    *   *Артикул (Part Number):* Строковый код детали завода-изготовителя.
    *   *Наименование:* Текстовое описание.
    *   *Код ячейки:* Адрес места хранения (Зона-Ряд-Полка).
    *   *Учетная цена:* Текущая себестоимость единицы.
    *   *Текущий остаток:* Вычисляемое или хранимое значение количества.
    *   *Срок годности:* Дата, до которой товар пригоден к реализации.

*   **Сущность «Складское движение»:**
    *   *Дата и время:* Момент совершения операции.
    *   *Тип операции:* Приход, Расход или Списание.
    *   *Комментарий:* Текстовое поле для примечаний кладовщика (например, «Брак при транспортировке»).

*   **Сущность «Позиция движения»:**
    *   *Количество:* Число единиц товара в данной операции.
    *   *Цена операции:* Цена, актуальная на момент совершения сделки (может отличаться от текущей учетной цены товара).

#### 2.3. Определение связей и их характеристик

Между выделенными сущностями установлены следующие связи:

1.  **Категория — Товар (1:M):**
    *   *Тип:* Один-ко-многим.
    *   *Описание:* Одна категория может содержать множество товаров, но каждый товар принадлежит только одной категории.
    *   *Обязательность:* Необязательная (товар может быть временно без категории), но при удалении категории ссылка должна обрабатываться корректно (`SET NULL`).

2.  **Производитель — Товар (1:M):**
    *   *Тип:* Один-ко-многим.
    *   *Описание:* Один производитель выпускает множество товаров. Эта связь критически важна для уникальности артикула.

3.  **Контрагент — Складское движение (1:M):**
    *   *Тип:* Один-ко-многим.
    *   *Описание:* Один контрагент может фигурировать во множестве накладных (история взаимодействий).

4.  **Складское движение — Позиция движения (1:M):**
    *   *Тип:* Один-ко-многим (Композиция).
    *   *Описание:* Один документ (накладная) состоит из множества строк с товарами. При удалении документа удаляются и все его строки (каскадное удаление).

5.  **Товар — Позиция движения (1:M):**
    *   *Тип:* Один-ко-многим.
    *   *Описание:* Один и тот же товар может встречаться в разных накладных в разное время.

#### 2.4. Построение концептуальной модели (ER-диаграмма)

На основе описанных выше сущностей и связей была разработана ER-диаграмма (Entity-Relationship).
Центральным звеном схемы является таблица **Товары**. Она окружена справочниками (**Категории**, **Производители**).
Динамика работы склада отражена через блок документов: таблица **Складские движения** связана с **Контрагентами**, а через промежуточную таблицу **Позиции движения** осуществляется связь с **Товарами**, образуя логическую структуру «многие-ко-многим» между накладными и товарами.

Такая структура удовлетворяет требованиям третьей нормальной формы (3NF), исключает дублирование информации и обеспечивает целостность данных при выполнении складских операций.

***

### <a id="logical_structure">3. Логическая структура базы данных</a>

Логическое проектирование — это процесс преобразования инфологической модели в схему базы данных, ориентированную на реляционную модель. На этом этапе абстрактные сущности трансформируются в таблицы, атрибуты — в поля (столбцы), а связи — во внешние ключи.

Главной задачей на данном этапе являлось устранение избыточности данных, которая может привести к нарушению их целостности. Для этого был применен метод нормализации.

#### 3.1. Нормализация отношений

Нормализация — это формальный процесс реорганизации данных, целью которого является устранение дублирования и предотвращение аномалий включения, обновления и удаления. В рамках курсового проекта схема базы данных была последовательно приведена к **Третьей нормальной форме (3NF)**.

**1. Первая нормальная форма (1NF)**
*   *Требование:* Все атрибуты таблицы должны быть атомарными (неделимыми), таблица не должна содержать повторяющихся групп, и все строки должны быть уникальны.
*   *Реализация:* В проекте отсутствуют поля, содержащие списки значений (например, мы не храним список купленных товаров в одной ячейке таблицы заказов). Для каждого товара в накладной создается отдельная запись. Все таблицы имеют определенный первичный ключ (`PRIMARY KEY`).

**2. Вторая нормальная форма (2NF)**
*   *Требование:* Таблица должна находиться в 1NF, и все неключевые атрибуты должны полностью зависеть от всего первичного ключа (а не от его части, если ключ составной).
*   *Реализация:* В нашей схеме используются суррогатные первичные ключи (`SERIAL ID`), что автоматически упрощает соблюдение 2NF. Мы выделили сущности «Товар» и «Позиция движения» в разные таблицы. Если бы мы хранили название товара в таблице позиций накладной, это нарушило бы 2NF, так как название зависит от товара, а не от факта его перемещения.

**3. Третья нормальная форма (3NF)**
*   *Требование:* Таблица должна находиться во 2NF, и в ней не должно быть транзитивных зависимостей (неключевые атрибуты не должны зависеть от других неключевых атрибутов).
*   *Реализация:*
    *   *Пример устранения нарушения:* Если бы в таблице `products` (Товары) мы хранили поле `manufacturer_country` (Страна производителя), возникла бы транзитивная зависимость: `product_id` -> `manufacturer_name` -> `manufacturer_country`.
    *   *Решение:* Данные о производителях вынесены в отдельную таблицу-справочник `manufacturers`. В таблице товаров остался только внешний ключ `manufacturer_id`. Теперь, если производитель сменит страну регистрации, нам достаточно обновить одну запись в справочнике, а не тысячи записей товаров.

#### 3.2. Описание результирующей структуры таблиц

В результате нормализации была сформирована следующая структура базы данных:

1.  **Таблица `categories` (Категории товаров)**
    Предназначена для группировки номенклатуры.
    *   `category_id` (PK): Уникальный идентификатор.
    *   `name`: Название категории (например, «Масла», «Ходовая часть»). Поле имеет ограничение `UNIQUE`.

2.  **Таблица `manufacturers` (Производители)**
    Справочник брендов.
    *   `manufacturer_id` (PK): Уникальный идентификатор.
    *   `name`: Наименование бренда.
    *   `country`: Страна происхождения.

3.  **Таблица `contractors` (Контрагенты)**
    Единый реестр юридических и физических лиц.
    *   `contractor_id` (PK): Уникальный идентификатор.
    *   `name`: Название организации или ФИО.
    *   `type`: Флаг типа контрагента (`supplier` — поставщик, `client` — получатель/клиент).
    *   `phone`, `email`, `address`: Контактная информация.

4.  **Таблица `products` (Товары)**
    Центральная таблица складского учета.
    *   `product_id` (PK): Уникальный идентификатор.
    *   `part_number`: Артикул детали (Part Number).
    *   `name`: Наименование товара.
    *   `location_code`: Код ячейки адресного хранения (по умолчанию 'RECEPTION').
    *   `stock_quantity`: Текущий остаток (целое число). Защищен от отрицательных значений (`CHECK >= 0`).
    *   `price`: Учетная цена (тип `NUMERIC` для точности).
    *   `expiration_date`: Срок годности (может быть `NULL` для запчастей, не имеющих срока хранения).
    *   `category_id` (FK): Ссылка на категорию.
    *   `manufacturer_id` (FK): Ссылка на производителя.

5.  **Таблица `stock_movements` (Журнал операций)**
    Хранит «шапки» документов движения.
    *   `movement_id` (PK): Уникальный номер документа.
    *   `created_at`: Дата и время создания (автоматически `NOW()`).
    *   `operation_type`: Тип операции (`in`, `out`, `writeoff`).
    *   `contractor_id` (FK): Ссылка на контрагента.

6.  **Таблица `movement_items` (Позиции документа)**
    Детализация состава накладной.
    *   `item_id` (PK): Уникальный идентификатор строки.
    *   `movement_id` (FK): Ссылка на документ. При удалении документа удаляются и строки (`ON DELETE CASCADE`).
    *   `product_id` (FK): Ссылка на товар.
    *   `quantity`: Количество товара в данной операции.
    *   `price`: Цена товара на момент операции (фиксируется исторически).

#### 3.3. Обеспечение ссылочной целостности

Для поддержания непротиворечивости данных были использованы ограничения внешних ключей (`FOREIGN KEY`):
*   При удалении **Категории** или **Производителя**, в таблице товаров соответствующие поля принимают значение `NULL` (`ON DELETE SET NULL`). Это позволяет сохранить товар в базе, даже если категория была удалена из справочника.
*   При удалении **Документа движения**, все его позиции удаляются автоматически (`ON DELETE CASCADE`), чтобы не оставлять «мусорные» записи, не привязанные ни к одной накладной.
*   Удаление **Товара**, по которому были движения, запрещено (`ON DELETE RESTRICT` в таблице позиций), так как это нарушит историю складского учета.


***

### <a id="physical_structure">4. Физическая структура базы данных и обоснование выбора инструментария</a>

Физическое проектирование — это этап, на котором логическая модель данных привязывается к конкретной программно-аппаратной среде хранения. На этом этапе принимаются решения о выборе Системы Управления Базами Данных (СУБД), определении типов данных, стратегии индексирования и настройке параметров хранения.

#### 4.1. Обоснование выбора СУБД PostgreSQL

Для реализации информационной системы склада была выбрана объектно-реляционная СУБД **PostgreSQL**. Данный выбор обусловлен детальным анализом требований к надежности и производительности системы:

1.  **Гарантия целостности транзакций (ACID):**
    Складской учет тесно связан с финансами. Принцип ACID (Atomicity, Consistency, Isolation, Durability) гарантирует, что при сбое питания или ошибке сервера транзакция либо выполнится целиком, либо не выполнится вовсе.
    *Пример:* При оформлении накладной происходит запись и в таблицу `stock_movements`, и в `movement_items`, и обновление `products`. PostgreSQL гарантирует, что не возникнет ситуации, когда товар списан, а накладная не создалась.

2.  **Механизм MVCC (Multiversion Concurrency Control):**
    PostgreSQL использует мультиверсионное управление параллельным доступом. Это означает, что операции чтения не блокируют операции записи, и наоборот.
    *Практическая польза:* Менеджер может формировать сложный отчет об остатках за месяц, и в это же самое время кладовщик может проводить новую накладную. Система не «зависнет», и оба пользователя получат корректные данные.

3.  **Мощный процедурный язык PL/pgSQL:**
    В отличие от MySQL или SQLite, PostgreSQL обладает развитым языком для написания хранимых процедур и триггеров. Это позволило реализовать бизнес-логику (контроль отрицательных остатков) непосредственно на уровне ядра базы данных, что является наиболее надежным способом защиты данных.

4.  **Поддержка сложных запросов и аналитики:**
    PostgreSQL эффективно оптимизирует сложные `JOIN`-запросы и поддерживает оконные функции, что необходимо для построения аналитических отчетов по динамике продаж и неликвидам.

#### 4.2. Выбор типов данных и их обоснование

Эффективность работы базы данных напрямую зависит от правильного выбора типов полей. Использование избыточных типов приводит к разрастанию размера БД на диске и замедлению выборки.

В проекте использованы следующие типы данных:

*   **`SERIAL` / `INTEGER`:**
    Используется для первичных ключей (`product_id`) и количественных показателей. Тип `INTEGER` занимает 4 байта и позволяет хранить значения до 2.1 млрд, что более чем достаточно для номенклатуры автомагазина.
*   **`NUMERIC(10, 2)`:**
    Используется для хранения цен (до 99 млн с копейками).
    *Важно:* Использование типов с плавающей точкой (`FLOAT`, `REAL`) для денег **недопустимо** из-за особенностей машинной арифметики (ошибки округления). Тип `NUMERIC` хранит числа точно, как десятичные дроби.
*   **`VARCHAR(n)`:**
    Используется для строковых данных (Название товара, Артикул). В отличие от типа `CHAR`, который дополняет строку пробелами до фиксированной длины, `VARCHAR` хранит только реальные символы + байт длины, что экономит дисковое пространство.
*   **`TIMESTAMP` и `DATE`:**
    *   `TIMESTAMP` (без временной зоны) используется для фиксации момента создания накладной.
    *   `DATE` используется для поля `expiration_date` (срок годности), так как время суток в данном случае не имеет значения.

#### 4.3. Стратегия индексирования и ограничения целостности

Для ускорения операций поиска и обеспечения валидности данных на физическом уровне реализованы следующие механизмы:

1.  **Первичные ключи (Primary Keys):**
    В каждой таблице создан первичный ключ, который в PostgreSQL автоматически создает уникальный индекс на основе B-Tree (сбалансированного дерева). Это обеспечивает мгновенный доступ к записи по её ID.
2.  **Внешние ключи (Foreign Keys):**
    Обеспечивают ссылочную целостность. Физически они запрещают удаление родительской записи (например, Категории), если на неё ссылаются дочерние записи (Товары).
3.  **Ограничения (Constraints):**
    *   `CHECK (stock_quantity >= 0)`: Физическое ограничение, проверяемое перед каждой вставкой или обновлением строки. Если условие нарушается, СУБД выбрасывает ошибку, предотвращая появление логических багов.
    *   `NOT NULL`: Обязательные поля (например, Артикул) защищены от пустых значений.

Таким образом, спроектированная физическая структура обеспечивает баланс между производительностью, объемом занимаемого места и надежностью хранения данных.

### <a id="db_realization">5. Реализация серверной части проекта</a>

**5.1. Создание таблиц и ограничений**
При создании таблиц использовались ограничения целостности (Constraints):
*   `CHECK (stock_quantity >= 0)`: Гарантирует отсутствие отрицательных остатков.
*   `CHECK (price >= 0)`: Запрещает отрицательные цены.
*   `CHECK (operation_type IN (...))`: Ограничивает список допустимых операций.

**5.2. Автоматизация (Триггеры)**
Для исключения ошибок оператора реализован триггер `trg_update_stock`. Он автоматически пересчитывает поле `stock_quantity` в таблице товаров при добавлении записей в журнал движений. Если товара недостаточно для списания, триггер генерирует исключение, и транзакция отменяется.

**5.3. Представления (Views)**
Создан слой абстракции данных:
*   `v_warehouse_stock`: Витрина остатков с расшифровкой справочников.
*   `v_expiring_goods`: Отчет о товарах с истекающим сроком годности (менее 30 дней).

### <a id="software_dev">6. Разработка клиентского программного обеспечения</a>

#### 6.1. Выбор и обоснование инструментария разработки
Клиентская часть приложения предназначена для взаимодействия конечного пользователя с базой данных. В качестве языка разработки был выбран **Python**.

**Преимущества Python для данной задачи:**
*   **Кроссплатформенность:** Приложение работает как на Windows, так и на Linux (актуально для импортозамещения).
*   **Скорость разработки (RAD):** Лаконичный синтаксис позволяет быстро создавать работающие прототипы.
*   **Экосистема библиотек:** Наличие стандартизированных драйверов (DB-API 2.0).

#### 6.2. Используемые библиотеки и паттерны
1.  **Psycopg2:** Высокопроизводительный адаптер для PostgreSQL. Обеспечивает безопасное соединение, защиту от SQL-инъекций и управление транзакциями.
2.  **Tkinter:** Стандартная библиотека для создания графического интерфейса (GUI). Не требует установки сторонних тяжеловесных фреймворков.

#### 6.3. Реализация взаимодействия с СУБД
Взаимодействие построено на **событийно-ориентированной модели**.
Алгоритм работы:
1.  Приложение подключается к БД.
2.  Пользователь вводит данные и нажимает кнопку операции.
3.  Python формирует SQL-запрос `INSERT`.
4.  PostgreSQL выполняет запрос и запускает триггеры.
5.  В случае ошибки (например, нехватка товара), СУБД возвращает исключение, которое перехватывается приложением, и пользователю выводится понятное сообщение.

Такой подход ("Тонкий клиент") позволяет сосредоточить защиту данных на стороне сервера, оставляя клиенту только функции интерфейса.

***

## <a id="conclusion">Заключение</a>

В ходе выполнения курсовой работы была спроектирована и программно реализована информационная система для автоматизации складского учета магазина автотоваров.

**Основные результаты работы:**
1.  **Анализ предметной области:** Изучены процессы складской логистики, выявлены недостатки ручного учета и сформулированы требования к системе.
2.  **Проектирование базы данных:** Разработана нормализованная структура БД (3NF), обеспечивающая целостность данных и отсутствие избыточности.
3.  **Реализация в СУБД:** В среде PostgreSQL созданы таблицы, индексы и ограничения. Реализована серверная бизнес-логика на языке PL/pgSQL (триггеры), автоматизирующая пересчет остатков.
4.  **Разработка ПО:** Создано клиентское приложение на языке Python, предоставляющее удобный интерфейс для работы кладовщика. Реализованы функции просмотра остатков, оформления накладных и обработки ошибок.

**Практическая значимость:**
Разработанный программный комплекс представляет собой готовое решение для автоматизации малого и среднего склада автозапчастей. Внедрение системы позволит сократить время обработки заказов, минимизировать потери от пересортицы и обеспечить строгий контроль за сроками годности товаров.

***

## <a id="literature">Список использованных информационных источников</a>

1.  Дейт К. Дж. Введение в системы баз данных. – 8-е изд. – М.: Вильямс, 2016.
2.  Кузнецов С.Д. Основы баз данных. – М.: Интернет-Университет Информационных Технологий, 2017.
3.  Луц М. Программирование на Python, том 1. – 4-е изд. – СПб.: Символ-Плюс, 2011.
4.  Официальная документация PostgreSQL [Электронный ресурс]. – Режим доступа: https://www.postgresql.org/docs/
5.  Документация библиотеки Psycopg2 [Электронный ресурс]. – Режим доступа: https://www.psycopg.org/docs/

***

## <a id="applications">Приложения</a>

### Приложение А. SQL-скрипт создания базы данных

```sql
-- 1. ОЧИСТКА БД
DROP VIEW IF EXISTS v_expiring_goods;
DROP VIEW IF EXISTS v_movement_history;
DROP VIEW IF EXISTS v_warehouse_stock;
DROP TABLE IF EXISTS movement_items CASCADE;
DROP TABLE IF EXISTS stock_movements CASCADE;
DROP TABLE IF EXISTS products CASCADE;
DROP TABLE IF EXISTS contractors CASCADE;
DROP TABLE IF EXISTS manufacturers CASCADE;
DROP TABLE IF EXISTS categories CASCADE;

-- 2. СОЗДАНИЕ СПРАВОЧНИКОВ
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE
);

CREATE TABLE manufacturers (
    manufacturer_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    country VARCHAR(50)
);

CREATE TABLE contractors (
    contractor_id SERIAL PRIMARY KEY,
    name VARCHAR(150) NOT NULL,
    type VARCHAR(20) NOT NULL CHECK (type IN ('supplier', 'client')),
    phone VARCHAR(20),
    email VARCHAR(100),
    address TEXT
);

-- 3. СОЗДАНИЕ ОСНОВНЫХ ТАБЛИЦ
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    part_number VARCHAR(50) NOT NULL,
    name VARCHAR(255) NOT NULL,
    location_code VARCHAR(20) DEFAULT 'RECEPTION', 
    price NUMERIC(10, 2) NOT NULL CHECK (price >= 0),
    stock_quantity INTEGER NOT NULL DEFAULT 0 CHECK (stock_quantity >= 0),
    expiration_date DATE,
    category_id INTEGER REFERENCES categories(category_id) ON DELETE SET NULL,
    manufacturer_id INTEGER REFERENCES manufacturers(manufacturer_id) ON DELETE SET NULL
);

CREATE TABLE stock_movements (
    movement_id SERIAL PRIMARY KEY,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    operation_type VARCHAR(10) NOT NULL CHECK (operation_type IN ('in', 'out', 'writeoff')),
    contractor_id INTEGER REFERENCES contractors(contractor_id) ON DELETE SET NULL,
    comments TEXT
);

CREATE TABLE movement_items (
    item_id SERIAL PRIMARY KEY,
    movement_id INTEGER REFERENCES stock_movements(movement_id) ON DELETE CASCADE,
    product_id INTEGER REFERENCES products(product_id) ON DELETE RESTRICT,
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    price NUMERIC(10, 2) NOT NULL
);

-- 4. ТРИГГЕРЫ (АВТОМАТИЗАЦИЯ)
CREATE OR REPLACE FUNCTION update_stock_on_movement()
RETURNS TRIGGER AS $$
DECLARE
    op_type VARCHAR(10);
BEGIN
    SELECT operation_type INTO op_type FROM stock_movements WHERE movement_id = NEW.movement_id;

    IF op_type = 'in' THEN
        UPDATE products SET stock_quantity = stock_quantity + NEW.quantity WHERE product_id = NEW.product_id;
    ELSIF op_type IN ('out', 'writeoff') THEN
        IF (SELECT stock_quantity FROM products WHERE product_id = NEW.product_id) < NEW.quantity THEN
            RAISE EXCEPTION 'Ошибка: Недостаточно товара на складе!';
        END IF;
        UPDATE products SET stock_quantity = stock_quantity - NEW.quantity WHERE product_id = NEW.product_id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_stock
AFTER INSERT ON movement_items
FOR EACH ROW
EXECUTE FUNCTION update_stock_on_movement();

-- 5. ПРЕДСТАВЛЕНИЯ (VIEWS)
CREATE OR REPLACE VIEW v_warehouse_stock AS
SELECT 
    p.part_number AS Артикул,
    p.name AS Товар,
    m.name AS Бренд,
    p.location_code AS Ячейка,
    p.stock_quantity AS Остаток,
    p.price AS Учетная_Цена,
    (p.stock_quantity * p.price) AS Сумма_Остатка
FROM products p
LEFT JOIN manufacturers m ON p.manufacturer_id = m.manufacturer_id;

CREATE OR REPLACE VIEW v_expiring_goods AS
SELECT 
    p.part_number, p.name, p.location_code, p.stock_quantity, p.expiration_date,
    CASE 
        WHEN p.expiration_date < CURRENT_DATE THEN 'ПРОСРОЧЕНО'
        ELSE 'Истекает скоро'
    END AS Статус
FROM products p
WHERE p.expiration_date IS NOT NULL AND p.stock_quantity > 0 AND p.expiration_date <= (CURRENT_DATE + INTERVAL '30 days');

-- 6. ТЕСТОВЫЕ ДАННЫЕ
INSERT INTO categories (name) VALUES ('Масла'), ('Фильтры');
INSERT INTO manufacturers (name, country) VALUES ('Shell', 'EU'), ('Mann', 'DE');
INSERT INTO contractors (name, type) VALUES ('ООО Поставщик', 'supplier'), ('Магазин №1', 'client');
INSERT INTO products (part_number, name, location_code, price, category_id, manufacturer_id, expiration_date) 
VALUES ('HELIX-5W40', 'Масло Shell Helix Ultra 4л', 'A-01-01', 4000.00, 1, 1, CURRENT_DATE + INTERVAL '20 days');
```

### Приложение Б. Исходный код клиентского приложения (Python)

```python
import tkinter as tk
from tkinter import ttk, messagebox
import psycopg2
from psycopg2 import Error

# Конфигурация подключения
DB_CONFIG = {
    "host": "localhost",
    "user": "postgres",
    "password": "YOUR_PASSWORD", # Заменить на реальный пароль
    "database": "autoparts_db"
}

class WarehouseApp:
    def __init__(self, root):
        self.root = root
        self.root.title("АРМ Склад Автотоваров")
        self.root.geometry("900x600")
        
        self.conn = None
        if not self.connect_db():
            root.destroy()
            return

        self.notebook = ttk.Notebook(root)
        self.notebook.pack(expand=True, fill='both', padx=10, pady=10)

        self.tab_stock = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_stock, text="Складские остатки")
        self.setup_stock_tab()

        self.tab_ops = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_ops, text="Оформление операций")
        self.setup_ops_tab()
        
        self.refresh_stock()

    def connect_db(self):
        try:
            self.conn = psycopg2.connect(**DB_CONFIG)
            return True
        except (Exception, Error) as error:
            messagebox.showerror("Ошибка БД", f"Ошибка подключения:\n{error}")
            return False

    def setup_stock_tab(self):
        btn_refresh = ttk.Button(self.tab_stock, text="Обновить", command=self.refresh_stock)
        btn_refresh.pack(pady=10)
        
        cols = ("art", "brand", "name", "loc", "qty", "price", "sum")
        self.tree = ttk.Treeview(self.tab_stock, columns=cols, show="headings")
        headers = ["Артикул", "Бренд", "Товар", "Ячейка", "Остаток", "Цена", "Сумма"]
        for col, h in zip(cols, headers):
            self.tree.heading(col, text=h)
        self.tree.pack(expand=True, fill='both')

    def setup_ops_tab(self):
        frame = ttk.Frame(self.tab_ops)
        frame.pack(padx=20, pady=20)
        
        ttk.Label(frame, text="ID Товара:").grid(row=0, column=0)
        self.entry_id = ttk.Entry(frame)
        self.entry_id.grid(row=0, column=1)
        
        ttk.Label(frame, text="Количество:").grid(row=1, column=0)
        self.entry_qty = ttk.Entry(frame)
        self.entry_qty.grid(row=1, column=1)
        
        self.op_var = tk.StringVar(value="in")
        ttk.Radiobutton(frame, text="Приход", variable=self.op_var, value="in").grid(row=2, column=1)
        ttk.Radiobutton(frame, text="Расход", variable=self.op_var, value="out").grid(row=3, column=1)
        
        ttk.Button(frame, text="Выполнить", command=self.execute_op).grid(row=4, column=0, columnspan=2, pady=10)

    def refresh_stock(self):
        for row in self.tree.get_children(): self.tree.delete(row)
        try:
            cur = self.conn.cursor()
            cur.execute("SELECT * FROM v_warehouse_stock")
            for row in cur.fetchall():
                self.tree.insert("", tk.END, values=row)
            cur.close()
        except Error as e:
            messagebox.showerror("Ошибка", str(e))

    def execute_op(self):
        try:
            cur = self.conn.cursor()
            op = self.op_var.get()
            # Создаем накладную
            cur.execute("INSERT INTO stock_movements (operation_type, contractor_id) VALUES (%s, 1) RETURNING movement_id", (op,))
            mov_id = cur.fetchone()[0]
            # Добавляем товар (цену берем из базы для упрощения)
            cur.execute("SELECT price FROM products WHERE product_id = %s", (self.entry_id.get(),))
            price_row = cur.fetchone()
            if not price_row:
                 messagebox.showerror("Ошибка", "Товар не найден")
                 return
            price = price_row[0]
            
            cur.execute("INSERT INTO movement_items (movement_id, product_id, quantity, price) VALUES (%s, %s, %s, %s)",
                        (mov_id, self.entry_id.get(), self.entry_qty.get(), price))
            self.conn.commit()
            messagebox.showinfo("Успех", "Операция выполнена")
            self.refresh_stock()
        except Exception as e:
            self.conn.rollback()
            messagebox.showerror("Ошибка", str(e))

if __name__ == "__main__":
    root = tk.Tk()
    app = WarehouseApp(root)
    root.mainloop()
```
